define(["exports", "./style-settings.js", "./css-parse.js", "./common-regex.js", "./unscoped-style-handler.js"], function (_exports, _styleSettings, _cssParse, _commonRegex, _unscopedStyleHandler) {
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.toCssText = toCssText;
  _exports.rulesForStyle = rulesForStyle;
  _exports.isKeyframesSelector = isKeyframesSelector;
  _exports.forEachRule = forEachRule;
  _exports.applyCss = applyCss;
  _exports.createScopeStyle = createScopeStyle;
  _exports.applyStylePlaceHolder = applyStylePlaceHolder;
  _exports.applyStyle = applyStyle;
  _exports.isTargetedBuild = isTargetedBuild;
  _exports.getCssBuildType = getCssBuildType;
  _exports.processVariableAndFallback = processVariableAndFallback;
  _exports.setElementClassRaw = setElementClassRaw;
  _exports.getIsExtends = getIsExtends;
  _exports.gatherStyleText = gatherStyleText;

  // eslint-disable-line no-unused-vars

  /**
   * @param {string|StyleNode} rules
   * @param {function(StyleNode)=} callback
   * @return {string}
   */
  function toCssText(rules, callback) {
    if (!rules) {
      return '';
    }

    if (typeof rules === 'string') {
      rules = (0, _cssParse.parse)(rules);
    }

    if (callback) {
      forEachRule(rules, callback);
    }

    return (0, _cssParse.stringify)(rules, _styleSettings.nativeCssVariables);
  }
  /**
   * @param {HTMLStyleElement} style
   * @return {StyleNode}
   */


  function rulesForStyle(style) {
    if (!style['__cssRules'] && style.textContent) {
      style['__cssRules'] = (0, _cssParse.parse)(style.textContent);
    }

    return style['__cssRules'] || null;
  } // Tests if a rule is a keyframes selector, which looks almost exactly
  // like a normal selector but is not (it has nothing to do with scoping
  // for example).

  /**
   * @param {StyleNode} rule
   * @return {boolean}
   */


  function isKeyframesSelector(rule) {
    return Boolean(rule['parent']) && rule['parent']['type'] === _cssParse.types.KEYFRAMES_RULE;
  }
  /**
   * @param {StyleNode} node
   * @param {Function=} styleRuleCallback
   * @param {Function=} keyframesRuleCallback
   * @param {boolean=} onlyActiveRules
   */


  function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
    if (!node) {
      return;
    }

    var skipRules = false;
    var type = node['type'];

    if (onlyActiveRules) {
      if (type === _cssParse.types.MEDIA_RULE) {
        var matchMedia = node['selector'].match(_commonRegex.MEDIA_MATCH);

        if (matchMedia) {
          // if rule is a non matching @media rule, skip subrules
          if (!window.matchMedia(matchMedia[1]).matches) {
            skipRules = true;
          }
        }
      }
    }

    if (type === _cssParse.types.STYLE_RULE) {
      styleRuleCallback(node);
    } else if (keyframesRuleCallback && type === _cssParse.types.KEYFRAMES_RULE) {
      keyframesRuleCallback(node);
    } else if (type === _cssParse.types.MIXIN_RULE) {
      skipRules = true;
    }

    var r$ = node['rules'];

    if (r$ && !skipRules) {
      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
        forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
      }
    }
  } // add a string of cssText to the document.

  /**
   * @param {string} cssText
   * @param {string} moniker
   * @param {Node} target
   * @param {Node} contextNode
   * @return {HTMLStyleElement}
   */


  function applyCss(cssText, moniker, target, contextNode) {
    var style = createScopeStyle(cssText, moniker);
    applyStyle(style, target, contextNode);
    return style;
  }
  /**
   * @param {string} cssText
   * @param {string} moniker
   * @return {HTMLStyleElement}
   */


  function createScopeStyle(cssText, moniker) {
    var style =
    /** @type {HTMLStyleElement} */
    document.createElement('style');

    if (moniker) {
      style.setAttribute('scope', moniker);
    }

    style.textContent = cssText;
    return style;
  }
  /**
   * Track the position of the last added style for placing placeholders
   * @type {Node}
   */


  var lastHeadApplyNode = null; // insert a comment node as a styling position placeholder.

  /**
   * @param {string} moniker
   * @return {!Comment}
   */

  function applyStylePlaceHolder(moniker) {
    var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
    var after = lastHeadApplyNode ? lastHeadApplyNode['nextSibling'] : null;
    var scope = document.head;
    scope.insertBefore(placeHolder, after || scope.firstChild);
    lastHeadApplyNode = placeHolder;
    return placeHolder;
  }
  /**
   * @param {HTMLStyleElement} style
   * @param {?Node} target
   * @param {?Node} contextNode
   */


  function applyStyle(style, target, contextNode) {
    target = target || document.head;
    var after = contextNode && contextNode.nextSibling || target.firstChild;
    target.insertBefore(style, after);

    if (!lastHeadApplyNode) {
      lastHeadApplyNode = style;
    } else {
      // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode
      var position = style.compareDocumentPosition(lastHeadApplyNode);

      if (position === Node.DOCUMENT_POSITION_PRECEDING) {
        lastHeadApplyNode = style;
      }
    }
  }
  /**
   * @param {string} buildType
   * @return {boolean}
   */


  function isTargetedBuild(buildType) {
    return _styleSettings.nativeShadow ? buildType === 'shadow' : buildType === 'shady';
  }
  /**
   * @param {Element} element
   * @return {?string}
   */


  function getCssBuildType(element) {
    return element.getAttribute('css-build');
  }
  /**
   * Walk from text[start] matching parens and
   * returns position of the outer end paren
   * @param {string} text
   * @param {number} start
   * @return {number}
   */


  function findMatchingParen(text, start) {
    var level = 0;

    for (var i = start, l = text.length; i < l; i++) {
      if (text[i] === '(') {
        level++;
      } else if (text[i] === ')') {
        if (--level === 0) {
          return i;
        }
      }
    }

    return -1;
  }
  /**
   * @param {string} str
   * @param {function(string, string, string, string)} callback
   */


  function processVariableAndFallback(str, callback) {
    // find 'var('
    var start = str.indexOf('var(');

    if (start === -1) {
      // no var?, everything is prefix
      return callback(str, '', '', '');
    } //${prefix}var(${inner})${suffix}


    var end = findMatchingParen(str, start + 3);
    var inner = str.substring(start + 4, end);
    var prefix = str.substring(0, start); // suffix may have other variables

    var suffix = processVariableAndFallback(str.substring(end + 1), callback);
    var comma = inner.indexOf(','); // value and fallback args should be trimmed to match in property lookup

    if (comma === -1) {
      // variable, no fallback
      return callback(prefix, inner.trim(), '', suffix);
    } // var(${value},${fallback})


    var value = inner.substring(0, comma).trim();
    var fallback = inner.substring(comma + 1).trim();
    return callback(prefix, value, fallback, suffix);
  }
  /**
   * @param {Element} element
   * @param {string} value
   */


  function setElementClassRaw(element, value) {
    // use native setAttribute provided by ShadyDOM when setAttribute is patched
    if (_styleSettings.nativeShadow) {
      element.setAttribute('class', value);
    } else {
      window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);
    }
  }
  /**
   * @param {Element | {is: string, extends: string}} element
   * @return {{is: string, typeExtension: string}}
   */


  function getIsExtends(element) {
    var localName = element['localName'];
    var is = '',
        typeExtension = '';
    /*
    NOTE: technically, this can be wrong for certain svg elements
    with `-` in the name like `<font-face>`
    */

    if (localName) {
      if (localName.indexOf('-') > -1) {
        is = localName;
      } else {
        typeExtension = localName;
        is = element.getAttribute && element.getAttribute('is') || '';
      }
    } else {
      is =
      /** @type {?} */
      element.is;
      typeExtension =
      /** @type {?} */
      element.extends;
    }

    return {
      is: is,
      typeExtension: typeExtension
    };
  }
  /**
   * @param {Element|DocumentFragment} element
   * @return {string}
   */


  function gatherStyleText(element) {
    /** @type {!Array<string>} */
    var styleTextParts = [];
    var styles =
    /** @type {!NodeList<!HTMLStyleElement>} */
    element.querySelectorAll('style');

    for (var i = 0; i < styles.length; i++) {
      var style = styles[i];

      if ((0, _unscopedStyleHandler.isUnscopedStyle)(style)) {
        if (!_styleSettings.nativeShadow) {
          (0, _unscopedStyleHandler.processUnscopedStyle)(style);
          style.parentNode.removeChild(style);
        }
      } else {
        styleTextParts.push(style.textContent);
        style.parentNode.removeChild(style);
      }
    }

    return styleTextParts.join('').trim();
  }
});