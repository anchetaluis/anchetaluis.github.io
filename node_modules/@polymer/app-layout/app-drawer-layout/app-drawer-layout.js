define(["../../polymer/polymer-legacy.js", "../../iron-media-query/iron-media-query.js", "../app-layout-behavior/app-layout-behavior.js", "../../polymer/lib/legacy/polymer-fn.js", "../../polymer/lib/utils/html-tag.js", "../../polymer/lib/legacy/polymer.dom.js", "../../polymer/lib/utils/render-status.js"], function (_polymerLegacy, _ironMediaQuery, _appLayoutBehavior, _polymerFn, _htmlTag, _polymerDom, _renderStatus) {
  "use strict";

  var _templateObject_54e0aaa0025f11ea96187b7d46f3386f = /*#__PURE__*/ babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: block;\n        /**\n         * Force app-drawer-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements.\n         */\n        position: relative;\n        z-index: 0;\n      }\n\n      :host ::slotted([slot=drawer]) {\n        z-index: 1;\n      }\n\n      :host([fullbleed]) {\n        @apply --layout-fit;\n      }\n\n      #contentContainer {\n        /* Create a stacking context here so that all children appear below the header. */\n        position: relative;\n        z-index: 0;\n        height: 100%;\n        transition: var(--app-drawer-layout-content-transition, none);\n      }\n\n      #contentContainer[drawer-position=left] {\n        margin-left: var(--app-drawer-width, 256px);\n      }\n\n      #contentContainer[drawer-position=right] {\n        margin-right: var(--app-drawer-width, 256px);\n      }\n    </style>\n\n    <slot id=\"drawerSlot\" name=\"drawer\"></slot>\n\n    <div id=\"contentContainer\" drawer-position$=\"[[_drawerPosition]]\">\n      <slot></slot>\n    </div>\n\n    <iron-media-query query=\"[[_computeMediaQuery(forceNarrow, responsiveWidth)]]\" on-query-matches-changed=\"_onQueryMatchesChanged\"></iron-media-query>\n"], ["\n    <style>\n      :host {\n        display: block;\n        /**\n         * Force app-drawer-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements.\n         */\n        position: relative;\n        z-index: 0;\n      }\n\n      :host ::slotted([slot=drawer]) {\n        z-index: 1;\n      }\n\n      :host([fullbleed]) {\n        @apply --layout-fit;\n      }\n\n      #contentContainer {\n        /* Create a stacking context here so that all children appear below the header. */\n        position: relative;\n        z-index: 0;\n        height: 100%;\n        transition: var(--app-drawer-layout-content-transition, none);\n      }\n\n      #contentContainer[drawer-position=left] {\n        margin-left: var(--app-drawer-width, 256px);\n      }\n\n      #contentContainer[drawer-position=right] {\n        margin-right: var(--app-drawer-width, 256px);\n      }\n    </style>\n\n    <slot id=\"drawerSlot\" name=\"drawer\"></slot>\n\n    <div id=\"contentContainer\" drawer-position\\$=\"[[_drawerPosition]]\">\n      <slot></slot>\n    </div>\n\n    <iron-media-query query=\"[[_computeMediaQuery(forceNarrow, responsiveWidth)]]\" on-query-matches-changed=\"_onQueryMatchesChanged\"></iron-media-query>\n"]);

  (0, _polymerFn.Polymer)({
    _template: (0, _htmlTag.html)(_templateObject_54e0aaa0025f11ea96187b7d46f3386f),
    is: 'app-drawer-layout',
    behaviors: [_appLayoutBehavior.AppLayoutBehavior],
    properties: {
      /**
       * If true, ignore `responsiveWidth` setting and force the narrow layout.
       */
      forceNarrow: {
        type: Boolean,
        value: false
      },

      /**
       * If the viewport's width is smaller than this value, the panel will change
       * to narrow layout. In the mode the drawer will be closed.
       */
      responsiveWidth: {
        type: String,
        value: '640px'
      },

      /**
       * Returns true if it is in narrow layout. This is useful if you need to
       * show/hide elements based on the layout.
       */
      narrow: {
        type: Boolean,
        reflectToAttribute: true,
        readOnly: true,
        notify: true
      },

      /**
       * If true, the drawer will initially be opened when in narrow layout mode.
       */
      openedWhenNarrow: {
        type: Boolean,
        value: false
      },
      _drawerPosition: {
        type: String
      }
    },
    listeners: {
      'click': '_clickHandler'
    },
    observers: ['_narrowChanged(narrow)'],

    /**
     * A reference to the app-drawer element.
     *
     * @property drawer
     */
    get drawer() {
      return (0, _polymerDom.dom)(this.$.drawerSlot).getDistributedNodes()[0];
    },

    attached: function attached() {
      // Disable drawer transitions until after app-drawer-layout sets the initial
      // opened state.
      var drawer = this.drawer;

      if (drawer) {
        drawer.setAttribute('no-transition', '');
      }
    },
    _clickHandler: function _clickHandler(e) {
      var target = (0, _polymerDom.dom)(e).localTarget;

      if (target && target.hasAttribute('drawer-toggle')) {
        var drawer = this.drawer;

        if (drawer && !drawer.persistent) {
          drawer.toggle();
        }
      }
    },
    _updateLayoutStates: function _updateLayoutStates() {
      var drawer = this.drawer;

      if (!this.isAttached || !drawer) {
        return;
      }

      this._drawerPosition = this.narrow ? null : drawer.position;

      if (this._drawerNeedsReset) {
        if (this.narrow) {
          drawer.opened = this.openedWhenNarrow;
          drawer.persistent = false;
        } else {
          drawer.opened = drawer.persistent = true;
        }

        if (drawer.hasAttribute('no-transition')) {
          // Enable drawer transitions after app-drawer-layout sets the initial
          // opened state.
          (0, _renderStatus.afterNextRender)(this, function () {
            drawer.removeAttribute('no-transition');
          });
        }

        this._drawerNeedsReset = false;
      }
    },
    _narrowChanged: function _narrowChanged() {
      this._drawerNeedsReset = true;
      this.resetLayout();
    },
    _onQueryMatchesChanged: function _onQueryMatchesChanged(event) {
      this._setNarrow(event.detail.value);
    },
    _computeMediaQuery: function _computeMediaQuery(forceNarrow, responsiveWidth) {
      return forceNarrow ? '(min-width: 0px)' : '(max-width: ' + responsiveWidth + ')';
    }
  });
});