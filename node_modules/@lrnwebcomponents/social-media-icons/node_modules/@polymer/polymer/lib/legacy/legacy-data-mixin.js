define(["exports", "./class.js", "../../polymer-legacy.js", "../utils/mixin.js", "../utils/templatize.js"], function (_exports, _class, _polymerLegacy, _mixin, _templatize) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LegacyDataMixin = void 0;

  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  var UndefinedArgumentError =
  /*#__PURE__*/
  function (_Error) {
    babelHelpers.inherits(UndefinedArgumentError, _Error);

    function UndefinedArgumentError(message, arg) {
      var _this;

      babelHelpers.classCallCheck(this, UndefinedArgumentError);
      _this = babelHelpers.possibleConstructorReturn(this, (UndefinedArgumentError.__proto__ || Object.getPrototypeOf(UndefinedArgumentError)).call(this, message));
      _this.arg = arg;
      _this.name = _this.constructor.name; // Affordances for ensuring instanceof works after babel ES5 compilation
      // TODO(kschaaf): Remove after polymer CLI updates to newer Babel that
      // sets the constructor/prototype correctly for subclassed builtins

      _this.constructor = UndefinedArgumentError;
      _this.__proto__ = UndefinedArgumentError.prototype;
      return _this;
    }

    return UndefinedArgumentError;
  }(Error);
  /**
   * Wraps effect functions to catch `UndefinedArgumentError`s and warn.
   *
   * @param {Object=} effect Effect metadata object
   * @param {Object=} fnName Name of user function, if known
   * @return {?Object|undefined} Effect metadata object
   */


  function wrapEffect(effect, fnName) {
    if (effect && effect.fn) {
      var fn = effect.fn;

      effect.fn = function () {
        try {
          fn.apply(this, arguments);
        } catch (e) {
          if (babelHelpers.instanceof(e, UndefinedArgumentError)) {
            console.warn("Argument '".concat(e.arg, "'").concat(fnName ? " for method '".concat(fnName, "'") : '', " was undefined. Ensure it has a default value, or else ensure the method handles the argument being undefined."));
          } else {
            throw e;
          }
        }
      };
    }

    return effect;
  }
  /**
   * Mixin to selectively add back Polymer 1.x's `undefined` rules
   * governing when observers & computing functions run based
   * on all arguments being defined (reference https://www.polymer-project.org/1.0/docs/devguide/observers#multi-property-observers).
   *
   * When loaded, all legacy elements (defined with `Polymer({...})`)
   * will have the mixin applied. The mixin only restores legacy data handling
   * if `_legacyUndefinedCheck: true` is set on the element's prototype.
   *
   * This mixin is intended for use to help migration from Polymer 1.x to
   * 2.x+ by allowing legacy code to work while identifying observers and
   * computing functions that need undefined checks to work without
   * the mixin in Polymer 2.
   *
   * @mixinFunction
   * @polymer
   * @summary Mixin to selectively add back Polymer 1.x's `undefined` rules
   * governing when observers & computing functions run.
   */


  var LegacyDataMixin = (0, _mixin.dedupingMixin)(function (superClass) {
    /**
     * @unrestricted
     * @private
     */
    var LegacyDataMixin =
    /*#__PURE__*/
    function (_superClass) {
      babelHelpers.inherits(LegacyDataMixin, _superClass);

      function LegacyDataMixin() {
        babelHelpers.classCallCheck(this, LegacyDataMixin);
        return babelHelpers.possibleConstructorReturn(this, (LegacyDataMixin.__proto__ || Object.getPrototypeOf(LegacyDataMixin)).apply(this, arguments));
      }

      babelHelpers.createClass(LegacyDataMixin, [{
        key: "_marshalArgs",

        /**
         * Overrides `Polymer.PropertyEffects` to add `undefined` argument
         * checking to match Polymer 1.x style rules
         *
         * @param {!Array<!MethodArg>} args Array of argument metadata
         * @param {string} path Property/path name that triggered the method effect
         * @param {Object} props Bag of current property changes
         * @return {Array<*>} Array of argument values
         * @private
         */
        value: function _marshalArgs(args, path, props) {
          var vals = babelHelpers.get(LegacyDataMixin.prototype.__proto__ || Object.getPrototypeOf(LegacyDataMixin.prototype), "_marshalArgs", this).call(this, args, path, props); // Per legacy data rules, single-property observers (whether in `properties`
          // and in `observers`) are called regardless of whether their argument is
          // undefined or not. Multi-property observers must have all arguments defined

          if (this._legacyUndefinedCheck && vals.length > 1) {
            for (var i = 0; i < vals.length; i++) {
              if (vals[i] === undefined || args[i].wildcard && vals[i].base === undefined) {
                // Break out of effect's control flow; will be caught in
                // wrapped property effect function below
                var name = args[i].name;
                throw new UndefinedArgumentError("Argument '".concat(name, "' is undefined."), name);
              }
            }
          }

          return vals;
        }
        /**
         * Overrides `Polyer.PropertyEffects` to wrap effect functions to
         * catch `UndefinedArgumentError`s and warn.
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @return {void}
         * @protected
         */

      }, {
        key: "_addPropertyEffect",
        value: function _addPropertyEffect(property, type, effect) {
          return babelHelpers.get(LegacyDataMixin.prototype.__proto__ || Object.getPrototypeOf(LegacyDataMixin.prototype), "_addPropertyEffect", this).call(this, property, type, wrapEffect(effect, effect && effect.info && effect.info.methodName));
        }
        /**
         * Overrides `Polyer.PropertyEffects` to wrap effect functions to
         * catch `UndefinedArgumentError`s and warn.
         *
         * @param {Object} templateInfo Template metadata to add effect to
         * @param {string} prop Property that should trigger the effect
         * @param {Object=} effect Effect metadata object
         * @return {void}
         * @protected
         * @nocollapse
         */

      }], [{
        key: "_addTemplatePropertyEffect",
        value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {
          // TODO(https://github.com/google/closure-compiler/issues/3240):
          //     Change back to just super.methodCall()
          return superClass._addTemplatePropertyEffect.call(this, templateInfo, prop, wrapEffect(effect));
        }
      }]);
      return LegacyDataMixin;
    }(superClass);

    return LegacyDataMixin;
  }); // LegacyDataMixin is applied to base class _before_ metaprogramming, to
  // ensure override of _addPropertyEffect et.al. are used by metaprogramming
  // performed in _finalizeClass

  _exports.LegacyDataMixin = LegacyDataMixin;

  _polymerLegacy.Polymer.Class = function (info, mixin) {
    return (0, _class.Class)(info, function (superClass) {
      return mixin ? mixin(LegacyDataMixin(superClass)) : LegacyDataMixin(superClass);
    });
  }; // Apply LegacyDataMixin to Templatizer instances as well, and defer
  // runtime switch to the root's host (_methodHost)

  /**
   * @mixinFunction
   * @polymer
   */


  var TemplatizeMixin = (0, _mixin.dedupingMixin)(function (superClass) {
    /**
     * @constructor
     * @extends {HTMLElement}
     */
    var legacyBase = LegacyDataMixin(superClass);
    /**
     * @private
     */

    var TemplateLegacy =
    /*#__PURE__*/
    function (_legacyBase) {
      babelHelpers.inherits(TemplateLegacy, _legacyBase);

      function TemplateLegacy() {
        babelHelpers.classCallCheck(this, TemplateLegacy);
        return babelHelpers.possibleConstructorReturn(this, (TemplateLegacy.__proto__ || Object.getPrototypeOf(TemplateLegacy)).apply(this, arguments));
      }

      babelHelpers.createClass(TemplateLegacy, [{
        key: "_legacyUndefinedCheck",
        get: function get() {
          return this._methodHost && this._methodHost._legacyUndefinedCheck;
        }
      }]);
      return TemplateLegacy;
    }(legacyBase);
    /** @type {!Polymer_PropertyEffects} */


    TemplateLegacy.prototype._methodHost;
    return TemplateLegacy;
  });
  _templatize.templatize.mixin = TemplatizeMixin;
  console.info('LegacyDataMixin will be applied to all legacy elements.\n' + 'Set `_legacyUndefinedCheck: true` on element class to enable.');
});