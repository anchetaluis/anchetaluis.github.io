define(["exports", "./element-mixin.js", "../utils/mixin.js"], function (_exports, _elementMixin, _mixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.DisableUpgradeMixin = void 0;

  /**
   * @fileoverview
   * @suppress {checkPrototypalTypes}
   * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
   * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
   * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
   * Google as part of the polymer project is also subject to an additional IP
   * rights grant found at http://polymer.github.io/PATENTS.txt
   */
  var DISABLED_ATTR = 'disable-upgrade';
  /**
   * Element class mixin that allows the element to boot up in a non-enabled
   * state when the `disable-upgrade` attribute is present. This mixin is
   * designed to be used with element classes like PolymerElement that perform
   * initial startup work when they are first connected. When the
   * `disable-upgrade` attribute is removed, if the element is connected, it
   * boots up and "enables" as it otherwise would; if it is not connected, the
   * element boots up when it is next connected.
   *
   * Using `disable-upgrade` with PolymerElement prevents any data propagation
   * to the element, any element DOM from stamping, or any work done in
   * connected/disconnctedCallback from occuring, but it does not prevent work
   * done in the element constructor.
   *
   * Note, this mixin must be applied on top of any element class that
   * itself implements a `connectedCallback` so that it can control the work
   * done in `connectedCallback`. For example,
   *
   *     MyClass = DisableUpgradeMixin(class extends BaseClass {...});
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin ElementMixin
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */

  var DisableUpgradeMixin = (0, _mixin.dedupingMixin)(function (base) {
    /**
     * @constructor
     * @implements {Polymer_ElementMixin}
     * @extends {HTMLElement}
     * @private
     */
    var superClass = (0, _elementMixin.ElementMixin)(base);
    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_DisableUpgradeMixin}
     */

    var DisableUpgradeClass =
    /*#__PURE__*/
    function (_superClass) {
      babelHelpers.inherits(DisableUpgradeClass, _superClass);

      function DisableUpgradeClass() {
        babelHelpers.classCallCheck(this, DisableUpgradeClass);
        return babelHelpers.possibleConstructorReturn(this, (DisableUpgradeClass.__proto__ || Object.getPrototypeOf(DisableUpgradeClass)).apply(this, arguments));
      }

      babelHelpers.createClass(DisableUpgradeClass, [{
        key: "attributeChangedCallback",

        /**
         * @override
         * @param {string} name Attribute name.
         * @param {?string} old The previous value for the attribute.
         * @param {?string} value The new value for the attribute.
         * @param {?string} namespace The XML namespace for the attribute.
         * @return {void}
         */
        value: function attributeChangedCallback(name, old, value, namespace) {
          if (name == DISABLED_ATTR) {
            if (!this.__dataEnabled && value == null && this.isConnected) {
              babelHelpers.get(DisableUpgradeClass.prototype.__proto__ || Object.getPrototypeOf(DisableUpgradeClass.prototype), "connectedCallback", this).call(this);
            }
          } else {
            babelHelpers.get(DisableUpgradeClass.prototype.__proto__ || Object.getPrototypeOf(DisableUpgradeClass.prototype), "attributeChangedCallback", this).call(this, name, old, value,
            /** @type {null|string} */
            namespace);
          }
        }
        /*
          NOTE: cannot gate on attribute because this is called before
          attributes are delivered. Therefore, we stub this out and
          call `super._initializeProperties()` manually.
        */

        /** @override */

      }, {
        key: "_initializeProperties",
        value: function _initializeProperties() {} // prevent user code in connected from running

        /** @override */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          if (this.__dataEnabled || !this.hasAttribute(DISABLED_ATTR)) {
            babelHelpers.get(DisableUpgradeClass.prototype.__proto__ || Object.getPrototypeOf(DisableUpgradeClass.prototype), "connectedCallback", this).call(this);
          }
        } // prevent element from turning on properties

        /** @override */

      }, {
        key: "_enableProperties",
        value: function _enableProperties() {
          if (!this.hasAttribute(DISABLED_ATTR)) {
            if (!this.__dataEnabled) {
              babelHelpers.get(DisableUpgradeClass.prototype.__proto__ || Object.getPrototypeOf(DisableUpgradeClass.prototype), "_initializeProperties", this).call(this);
            }

            babelHelpers.get(DisableUpgradeClass.prototype.__proto__ || Object.getPrototypeOf(DisableUpgradeClass.prototype), "_enableProperties", this).call(this);
          }
        } // only go if "enabled"

        /** @override */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          if (this.__dataEnabled) {
            babelHelpers.get(DisableUpgradeClass.prototype.__proto__ || Object.getPrototypeOf(DisableUpgradeClass.prototype), "disconnectedCallback", this).call(this);
          }
        }
      }], [{
        key: "observedAttributes",

        /**
         * @suppress {missingProperties} go/missingfnprops
         */
        get: function get() {
          return babelHelpers.get(DisableUpgradeClass.__proto__ || Object.getPrototypeOf(DisableUpgradeClass), "observedAttributes", this).concat(DISABLED_ATTR);
        }
      }]);
      return DisableUpgradeClass;
    }(superClass);

    return DisableUpgradeClass;
  });
  _exports.DisableUpgradeMixin = DisableUpgradeMixin;
});