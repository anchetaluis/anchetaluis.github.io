define(["exports", "./css-parse.js", "./style-settings.js", "./style-transformer.js", "./style-util.js", "./style-properties.js", "./style-placeholder.js", "./style-info.js", "./style-cache.js", "./document-watcher.js", "./template-map.js", "./apply-shim-utils.js", "./common-utils.js", "./custom-style-interface.js"], function (_exports, _cssParse, _styleSettings, _styleTransformer, StyleUtil, _styleProperties, _stylePlaceholder, _styleInfo2, _styleCache, _documentWatcher, _templateMap, ApplyShimUtils, _commonUtils, _customStyleInterface) {
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  _styleTransformer = babelHelpers.interopRequireDefault(_styleTransformer);
  StyleUtil = babelHelpers.interopRequireWildcard(StyleUtil);
  _styleProperties = babelHelpers.interopRequireDefault(_styleProperties);
  _styleInfo2 = babelHelpers.interopRequireDefault(_styleInfo2);
  _styleCache = babelHelpers.interopRequireDefault(_styleCache);
  _templateMap = babelHelpers.interopRequireDefault(_templateMap);
  ApplyShimUtils = babelHelpers.interopRequireWildcard(ApplyShimUtils);
  // eslint-disable-line no-unused-vars

  /** @type {!Object<string, string>} */
  var adoptedCssTextMap = {};
  /**
   * @const {StyleCache}
   */

  var styleCache = new _styleCache.default();

  var ScopingShim =
  /*#__PURE__*/
  function () {
    function ScopingShim() {
      babelHelpers.classCallCheck(this, ScopingShim);
      this._scopeCounter = {};
      this._documentOwner =
      /** @type {!HTMLElement} */
      document.documentElement;
      var ast = new _cssParse.StyleNode();
      ast['rules'] = [];
      this._documentOwnerStyleInfo = _styleInfo2.default.set(this._documentOwner, new _styleInfo2.default(ast));
      this._elementsHaveApplied = false;
      /** @type {?Object} */

      this._applyShim = null;
      /** @type {?CustomStyleInterfaceInterface} */

      this._customStyleInterface = null;
    }

    babelHelpers.createClass(ScopingShim, [{
      key: "flush",
      value: function flush() {
        (0, _documentWatcher.flush)();
      }
    }, {
      key: "_generateScopeSelector",
      value: function _generateScopeSelector(name) {
        var id = this._scopeCounter[name] = (this._scopeCounter[name] || 0) + 1;
        return "".concat(name, "-").concat(id);
      }
    }, {
      key: "getStyleAst",
      value: function getStyleAst(style) {
        return StyleUtil.rulesForStyle(style);
      }
    }, {
      key: "styleAstToString",
      value: function styleAstToString(ast) {
        return StyleUtil.toCssText(ast);
      }
    }, {
      key: "_gatherStyles",
      value: function _gatherStyles(template) {
        return StyleUtil.gatherStyleText(template.content);
      }
      /**
       * Prepare the styling and template for the given element type
       *
       * @param {!HTMLTemplateElement} template
       * @param {string} elementName
       * @param {string=} typeExtension
       */

    }, {
      key: "prepareTemplate",
      value: function prepareTemplate(template, elementName, typeExtension) {
        this.prepareTemplateDom(template, elementName);
        this.prepareTemplateStyles(template, elementName, typeExtension);
      }
      /**
       * Prepare styling for the given element type
       * @param {!HTMLTemplateElement} template
       * @param {string} elementName
       * @param {string=} typeExtension
       */

    }, {
      key: "prepareTemplateStyles",
      value: function prepareTemplateStyles(template, elementName, typeExtension) {
        if (template._prepared || _styleSettings.disableRuntime) {
          return;
        } // style placeholders are only used when ShadyDOM is active


        if (!_styleSettings.nativeShadow) {
          (0, _stylePlaceholder.ensureStylePlaceholder)(elementName);
        }

        template._prepared = true;
        template.name = elementName;
        template.extends = typeExtension;
        _templateMap.default[elementName] = template;
        var cssBuild = StyleUtil.getCssBuild(template);
        var optimalBuild = StyleUtil.isOptimalCssBuild(cssBuild);
        var info = {
          is: elementName,
          extends: typeExtension
        };
        var cssText = this._gatherStyles(template) + (adoptedCssTextMap[elementName] || ''); // check if the styling has mixin definitions or uses

        this._ensure();

        if (!optimalBuild) {
          var hasMixins = !cssBuild && (0, _commonUtils.detectMixin)(cssText);
          var ast = (0, _cssParse.parse)(cssText); // only run the applyshim transforms if there is a mixin involved

          if (hasMixins && _styleSettings.nativeCssVariables && this._applyShim) {
            this._applyShim['transformRules'](ast, elementName);
          }

          template['_styleAst'] = ast;
        }

        var ownPropertyNames = [];

        if (!_styleSettings.nativeCssVariables) {
          ownPropertyNames = _styleProperties.default.decorateStyles(template['_styleAst']);
        }

        if (!ownPropertyNames.length || _styleSettings.nativeCssVariables) {
          var root = _styleSettings.nativeShadow ? template.content : null;
          var placeholder = (0, _stylePlaceholder.getStylePlaceholder)(elementName);

          var style = this._generateStaticStyle(info, template['_styleAst'], root, placeholder, cssBuild, optimalBuild ? cssText : '');

          template._style = style;
        }

        template._ownPropertyNames = ownPropertyNames;
      }
      /**
       * @param {!Array<string>} cssTextArray
       * @param {string} elementName
       */

    }, {
      key: "prepareAdoptedCssText",
      value: function prepareAdoptedCssText(cssTextArray, elementName) {
        adoptedCssTextMap[elementName] = cssTextArray.join(' ');
      }
      /**
       * Prepare template for the given element type
       * @param {!HTMLTemplateElement} template
       * @param {string} elementName
       */

    }, {
      key: "prepareTemplateDom",
      value: function prepareTemplateDom(template, elementName) {
        if (_styleSettings.disableRuntime) {
          return;
        }

        var cssBuild = StyleUtil.getCssBuild(template);

        if (!_styleSettings.nativeShadow && cssBuild !== 'shady' && !template._domPrepared) {
          template._domPrepared = true;

          _styleTransformer.default.domAddScope(template.content, elementName);
        }
      }
      /**
       * @param {!{is: string, extends: (string|undefined)}} info
       * @param {!StyleNode} rules
       * @param {DocumentFragment} shadowroot
       * @param {Node} placeholder
       * @param {string} cssBuild
       * @param {string=} cssText
       * @return {?HTMLStyleElement}
       */

    }, {
      key: "_generateStaticStyle",
      value: function _generateStaticStyle(info, rules, shadowroot, placeholder, cssBuild, cssText) {
        cssText = _styleTransformer.default.elementStyles(info, rules, null, cssBuild, cssText);

        if (cssText.length) {
          return StyleUtil.applyCss(cssText, info.is, shadowroot, placeholder);
        }

        return null;
      }
    }, {
      key: "_prepareHost",
      value: function _prepareHost(host) {
        var _StyleUtil$getIsExten = StyleUtil.getIsExtends(host),
            is = _StyleUtil$getIsExten.is,
            typeExtension = _StyleUtil$getIsExten.typeExtension;

        var placeholder = (0, _stylePlaceholder.getStylePlaceholder)(is);
        var template = _templateMap.default[is];

        if (!template) {
          return;
        }

        var ast = template['_styleAst'];
        var ownStylePropertyNames = template._ownPropertyNames;
        var cssBuild = StyleUtil.getCssBuild(template);
        var styleInfo = new _styleInfo2.default(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild);

        _styleInfo2.default.set(host, styleInfo);

        return styleInfo;
      }
    }, {
      key: "_ensureApplyShim",
      value: function _ensureApplyShim() {
        if (this._applyShim) {
          return;
        } else if (window.ShadyCSS && window.ShadyCSS.ApplyShim) {
          this._applyShim =
          /** @type {!Object} */
          window.ShadyCSS.ApplyShim;
          this._applyShim['invalidCallback'] = ApplyShimUtils.invalidate;
        }
      }
    }, {
      key: "_ensureCustomStyleInterface",
      value: function _ensureCustomStyleInterface() {
        var _this = this;

        if (this._customStyleInterface) {
          return;
        } else if (window.ShadyCSS && window.ShadyCSS.CustomStyleInterface) {
          this._customStyleInterface =
          /** @type {!CustomStyleInterfaceInterface} */
          window.ShadyCSS.CustomStyleInterface;
          /** @type {function(!HTMLStyleElement)} */

          this._customStyleInterface['transformCallback'] = function (style) {
            _this.transformCustomStyleForDocument(style);
          };

          this._customStyleInterface['validateCallback'] = function () {
            requestAnimationFrame(function () {
              if (_this._customStyleInterface['enqueued'] || _this._elementsHaveApplied) {
                _this.flushCustomStyles();
              }
            });
          };
        }
      }
    }, {
      key: "_ensure",
      value: function _ensure() {
        this._ensureApplyShim();

        this._ensureCustomStyleInterface();
      }
      /**
       * Flush and apply custom styles to document
       */

    }, {
      key: "flushCustomStyles",
      value: function flushCustomStyles() {
        if (_styleSettings.disableRuntime) {
          return;
        }

        this._ensure();

        if (!this._customStyleInterface) {
          return;
        }

        var customStyles = this._customStyleInterface['processStyles'](); // early return if custom-styles don't need validation


        if (!this._customStyleInterface['enqueued']) {
          return;
        } // bail if custom styles are built optimally


        if (StyleUtil.isOptimalCssBuild(this._documentOwnerStyleInfo.cssBuild)) {
          return;
        }

        if (!_styleSettings.nativeCssVariables) {
          this._reorderCustomStylesRules(customStyles);

          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);

          this._applyCustomStyles(customStyles);

          if (this._elementsHaveApplied) {
            // if custom elements have upgraded and there are no native css variables, we must recalculate the whole tree
            this.styleDocument();
          }
        } else if (!this._documentOwnerStyleInfo.cssBuild) {
          this._revalidateCustomStyleApplyShim(customStyles);
        }

        this._customStyleInterface['enqueued'] = false;
      }
      /**
       * Reorder of custom styles for Custom Property shim
       * @param {!Array<!CustomStyleProvider>} customStyles
       */

    }, {
      key: "_reorderCustomStylesRules",
      value: function _reorderCustomStylesRules(customStyles) {
        var _this2 = this;

        var styles = customStyles.map(function (c) {
          return _this2._customStyleInterface['getStyleForCustomStyle'](c);
        }).filter(function (s) {
          return !!s;
        }); // sort styles in document order

        styles.sort(function (a, b) {
          // use `b.compare(a)` to be more straightforward
          var position = b.compareDocumentPosition(a);

          if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
            // A is after B, A should be higher sorted
            return 1;
          } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {
            // A is before B, A should be lower sorted
            return -1;
          } else {
            return 0;
          }
        }); // sort ast ordering for document

        this._documentOwnerStyleInfo.styleRules['rules'] = styles.map(function (s) {
          return StyleUtil.rulesForStyle(s);
        });
      }
      /**
       * Apply styles for the given element
       *
       * @param {!HTMLElement} host
       * @param {Object=} overrideProps
       */

    }, {
      key: "styleElement",
      value: function styleElement(host, overrideProps) {
        if (_styleSettings.disableRuntime) {
          if (overrideProps) {
            if (!_styleInfo2.default.get(host)) {
              _styleInfo2.default.set(host, new _styleInfo2.default(null));
            }

            var _styleInfo =
            /** @type {!StyleInfo} */
            _styleInfo2.default.get(host);

            this._mixOverrideStyleProps(_styleInfo, overrideProps);

            this.styleElementNativeVariables(host, _styleInfo);
          }

          return;
        }

        var styleInfo = _styleInfo2.default.get(host) || this._prepareHost(host); // if there is no style info at this point, bail


        if (!styleInfo) {
          return;
        } // Only trip the `elementsHaveApplied` flag if a node other that the root document has `applyStyle` called


        if (!this._isRootOwner(host)) {
          this._elementsHaveApplied = true;
        }

        if (overrideProps) {
          this._mixOverrideStyleProps(styleInfo, overrideProps);
        }

        if (!_styleSettings.nativeCssVariables) {
          this.styleElementShimVariables(host, styleInfo);
        } else {
          this.styleElementNativeVariables(host, styleInfo);
        }
      }
      /**
       * @param {!StyleInfo} styleInfo
       * @param {Object} overrideProps
       */

    }, {
      key: "_mixOverrideStyleProps",
      value: function _mixOverrideStyleProps(styleInfo, overrideProps) {
        styleInfo.overrideStyleProperties = styleInfo.overrideStyleProperties || {};
        Object.assign(styleInfo.overrideStyleProperties, overrideProps);
      }
      /**
       * @param {!HTMLElement} host
       * @param {!StyleInfo} styleInfo
       */

    }, {
      key: "styleElementShimVariables",
      value: function styleElementShimVariables(host, styleInfo) {
        this.flush();

        this._updateProperties(host, styleInfo);

        if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {
          this._applyStyleProperties(host, styleInfo);
        }
      }
      /**
       * @param {!HTMLElement} host
       * @param {!StyleInfo} styleInfo
       */

    }, {
      key: "styleElementNativeVariables",
      value: function styleElementNativeVariables(host, styleInfo) {
        var _StyleUtil$getIsExten2 = StyleUtil.getIsExtends(host),
            is = _StyleUtil$getIsExten2.is;

        if (styleInfo.overrideStyleProperties) {
          (0, _commonUtils.updateNativeProperties)(host, styleInfo.overrideStyleProperties);
        }

        var template = _templateMap.default[is]; // bail early if there is no shadowroot for this element

        if (!template && !this._isRootOwner(host)) {
          return;
        } // bail early if the template was built with polymer-css-build


        if (template && StyleUtil.elementHasBuiltCss(template)) {
          return;
        }

        if (template && template._style && !ApplyShimUtils.templateIsValid(template)) {
          // update template
          if (!ApplyShimUtils.templateIsValidating(template)) {
            this._ensure();

            this._applyShim && this._applyShim['transformRules'](template['_styleAst'], is);
            template._style.textContent = _styleTransformer.default.elementStyles(host, styleInfo.styleRules);
            ApplyShimUtils.startValidatingTemplate(template);
          } // update instance if native shadowdom


          if (_styleSettings.nativeShadow) {
            var root = host.shadowRoot;

            if (root) {
              var style = root.querySelector('style');

              if (style) {
                style.textContent = _styleTransformer.default.elementStyles(host, styleInfo.styleRules);
              }
            }
          }

          styleInfo.styleRules = template['_styleAst'];
        }
      }
    }, {
      key: "_styleOwnerForNode",
      value: function _styleOwnerForNode(node) {
        var root = StyleUtil.wrap(node).getRootNode();
        var host = root.host;

        if (host) {
          if (_styleInfo2.default.get(host) || this._prepareHost(host)) {
            return host;
          } else {
            return this._styleOwnerForNode(host);
          }
        }

        return this._documentOwner;
      }
    }, {
      key: "_isRootOwner",
      value: function _isRootOwner(node) {
        return node === this._documentOwner;
      }
    }, {
      key: "_applyStyleProperties",
      value: function _applyStyleProperties(host, styleInfo) {
        var is = StyleUtil.getIsExtends(host).is;
        var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);
        var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;
        var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;
        var oldScopeSelector = styleInfo.scopeSelector; // only generate new scope if cached style is not found

        styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);

        var style = _styleProperties.default.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);

        if (!_styleSettings.nativeShadow) {
          _styleProperties.default.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);
        }

        if (!cacheEntry) {
          styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);
        }

        return style;
      }
    }, {
      key: "_updateProperties",
      value: function _updateProperties(host, styleInfo) {
        var owner = this._styleOwnerForNode(host);

        var ownerStyleInfo = _styleInfo2.default.get(owner);

        var ownerProperties = ownerStyleInfo.styleProperties; // style owner has not updated properties yet
        // go up the chain and force property update,
        // except if the owner is the document

        if (owner !== this._documentOwner && !ownerProperties) {
          this._updateProperties(owner, ownerStyleInfo);

          ownerProperties = ownerStyleInfo.styleProperties;
        }

        var props = Object.create(ownerProperties || null);

        var hostAndRootProps = _styleProperties.default.hostAndRootPropertiesForScope(host, styleInfo.styleRules, styleInfo.cssBuild);

        var propertyData = _styleProperties.default.propertyDataFromStyles(ownerStyleInfo.styleRules, host);

        var propertiesMatchingHost = propertyData.properties;
        Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);

        this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);

        _styleProperties.default.reify(props);

        styleInfo.styleProperties = props;
      }
    }, {
      key: "_mixinOverrideStyles",
      value: function _mixinOverrideStyles(props, overrides) {
        for (var p in overrides) {
          var v = overrides[p]; // skip override props if they are not truthy or 0
          // in order to fall back to inherited values

          if (v || v === 0) {
            props[p] = v;
          }
        }
      }
      /**
       * Update styles of the whole document
       *
       * @param {Object=} properties
       */

    }, {
      key: "styleDocument",
      value: function styleDocument(properties) {
        this.styleSubtree(this._documentOwner, properties);
      }
      /**
       * Update styles of a subtree
       *
       * @param {!HTMLElement} host
       * @param {Object=} properties
       */

    }, {
      key: "styleSubtree",
      value: function styleSubtree(host, properties) {
        var wrappedHost = StyleUtil.wrap(host);
        var root = wrappedHost.shadowRoot;

        var isRootOwner = this._isRootOwner(host);

        if (root || isRootOwner) {
          this.styleElement(host, properties);
        }

        var descendantRoot = isRootOwner ? wrappedHost : root;

        if (descendantRoot) {
          var descendantHosts = Array.from(descendantRoot.querySelectorAll('*')).filter(function (x) {
            return StyleUtil.wrap(x).shadowRoot;
          });

          for (var i = 0; i < descendantHosts.length; i++) {
            this.styleSubtree(descendantHosts[i]);
          }
        }
      }
      /* Custom Style operations */

    }, {
      key: "_revalidateCustomStyleApplyShim",
      value: function _revalidateCustomStyleApplyShim(customStyles) {
        for (var i = 0; i < customStyles.length; i++) {
          var c = customStyles[i];

          var s = this._customStyleInterface['getStyleForCustomStyle'](c);

          if (s) {
            this._revalidateApplyShim(s);
          }
        }
      }
    }, {
      key: "_applyCustomStyles",
      value: function _applyCustomStyles(customStyles) {
        for (var i = 0; i < customStyles.length; i++) {
          var c = customStyles[i];

          var s = this._customStyleInterface['getStyleForCustomStyle'](c);

          if (s) {
            _styleProperties.default.applyCustomStyle(s, this._documentOwnerStyleInfo.styleProperties);
          }
        }
      }
    }, {
      key: "transformCustomStyleForDocument",
      value: function transformCustomStyleForDocument(style) {
        var _this3 = this;

        var cssBuild = StyleUtil.getCssBuild(style);

        if (cssBuild !== this._documentOwnerStyleInfo.cssBuild) {
          this._documentOwnerStyleInfo.cssBuild = cssBuild;
        }

        if (StyleUtil.isOptimalCssBuild(cssBuild)) {
          return;
        }

        var ast = StyleUtil.rulesForStyle(style);
        StyleUtil.forEachRule(ast, function (rule) {
          if (_styleSettings.nativeShadow) {
            _styleTransformer.default.normalizeRootSelector(rule);
          } else {
            _styleTransformer.default.documentRule(rule);
          }

          if (_styleSettings.nativeCssVariables && cssBuild === '') {
            _this3._ensure();

            _this3._applyShim && _this3._applyShim['transformRule'](rule);
          }
        });

        if (_styleSettings.nativeCssVariables) {
          style.textContent = StyleUtil.toCssText(ast);
        } else {
          this._documentOwnerStyleInfo.styleRules['rules'].push(ast);
        }
      }
    }, {
      key: "_revalidateApplyShim",
      value: function _revalidateApplyShim(style) {
        if (_styleSettings.nativeCssVariables && this._applyShim) {
          var ast = StyleUtil.rulesForStyle(style);

          this._ensure();

          this._applyShim['transformRules'](ast);

          style.textContent = StyleUtil.toCssText(ast);
        }
      }
    }, {
      key: "getComputedStyleValue",
      value: function getComputedStyleValue(element, property) {
        var value;

        if (!_styleSettings.nativeCssVariables) {
          // element is either a style host, or an ancestor of a style host
          var styleInfo = _styleInfo2.default.get(element) || _styleInfo2.default.get(this._styleOwnerForNode(element));

          value = styleInfo.styleProperties[property];
        } // fall back to the property value from the computed styling


        value = value || window.getComputedStyle(element).getPropertyValue(property); // trim whitespace that can come after the `:` in css
        // example: padding: 2px -> " 2px"

        return value ? value.trim() : '';
      } // given an element and a classString, replaces
      // the element's class with the provided classString and adds
      // any necessary ShadyCSS static and property based scoping selectors

    }, {
      key: "setElementClass",
      value: function setElementClass(element, classString) {
        var root = StyleUtil.wrap(element).getRootNode();
        var classes;

        if (classString) {
          var definitelyString = typeof classString === 'string' ? classString : String(classString);
          classes = definitelyString.split(/\s/);
        } else {
          classes = [];
        }

        var scopeName = root.host && root.host.localName; // If no scope, try to discover scope name from existing class.
        // This can occur if, for example, a template stamped element that
        // has been scoped is manipulated when not in a root.

        if (!scopeName) {
          var classAttr = element.getAttribute('class');

          if (classAttr) {
            var k$ = classAttr.split(/\s/);

            for (var i = 0; i < k$.length; i++) {
              if (k$[i] === _styleTransformer.default.SCOPE_NAME) {
                scopeName = k$[i + 1];
                break;
              }
            }
          }
        }

        if (scopeName) {
          classes.push(_styleTransformer.default.SCOPE_NAME, scopeName);
        }

        if (!_styleSettings.nativeCssVariables) {
          var styleInfo = _styleInfo2.default.get(element);

          if (styleInfo && styleInfo.scopeSelector) {
            classes.push(_styleProperties.default.XSCOPE_NAME, styleInfo.scopeSelector);
          }
        }

        StyleUtil.setElementClassRaw(element, classes.join(' '));
      }
    }, {
      key: "_styleInfoForNode",
      value: function _styleInfoForNode(node) {
        return _styleInfo2.default.get(node);
      }
      /**
       * @param {!Element} node
       * @param {string} scope
       */

    }, {
      key: "scopeNode",
      value: function scopeNode(node, scope) {
        _styleTransformer.default.element(node, scope);
      }
      /**
       * @param {!Element} node
       * @param {string} scope
       */

    }, {
      key: "unscopeNode",
      value: function unscopeNode(node, scope) {
        _styleTransformer.default.element(node, scope, true);
      }
      /**
       * @param {!Node} node
       * @return {string}
       */

    }, {
      key: "scopeForNode",
      value: function scopeForNode(node) {
        return (0, _documentWatcher.getOwnerScope)(node);
      }
      /**
       * @param {!Element} node
       * @return {string}
       */

    }, {
      key: "currentScopeForNode",
      value: function currentScopeForNode(node) {
        return (0, _documentWatcher.getCurrentScope)(node);
      }
    }]);
    return ScopingShim;
  }();
  /* exports */

  /* eslint-disable no-self-assign */


  _exports.default = ScopingShim;
  ScopingShim.prototype['flush'] = ScopingShim.prototype.flush;
  ScopingShim.prototype['prepareTemplate'] = ScopingShim.prototype.prepareTemplate;
  ScopingShim.prototype['styleElement'] = ScopingShim.prototype.styleElement;
  ScopingShim.prototype['styleDocument'] = ScopingShim.prototype.styleDocument;
  ScopingShim.prototype['styleSubtree'] = ScopingShim.prototype.styleSubtree;
  ScopingShim.prototype['getComputedStyleValue'] = ScopingShim.prototype.getComputedStyleValue;
  ScopingShim.prototype['setElementClass'] = ScopingShim.prototype.setElementClass;
  ScopingShim.prototype['_styleInfoForNode'] = ScopingShim.prototype._styleInfoForNode;
  ScopingShim.prototype['transformCustomStyleForDocument'] = ScopingShim.prototype.transformCustomStyleForDocument;
  ScopingShim.prototype['getStyleAst'] = ScopingShim.prototype.getStyleAst;
  ScopingShim.prototype['styleAstToString'] = ScopingShim.prototype.styleAstToString;
  ScopingShim.prototype['flushCustomStyles'] = ScopingShim.prototype.flushCustomStyles;
  ScopingShim.prototype['scopeNode'] = ScopingShim.prototype.scopeNode;
  ScopingShim.prototype['unscopeNode'] = ScopingShim.prototype.unscopeNode;
  ScopingShim.prototype['scopeForNode'] = ScopingShim.prototype.scopeForNode;
  ScopingShim.prototype['currentScopeForNode'] = ScopingShim.prototype.currentScopeForNode;
  ScopingShim.prototype['prepareAdoptedCssText'] = ScopingShim.prototype.prepareAdoptedCssText;
  /* eslint-enable no-self-assign */

  Object.defineProperties(ScopingShim.prototype, {
    'nativeShadow': {
      get: function get() {
        return _styleSettings.nativeShadow;
      }
    },
    'nativeCss': {
      get: function get() {
        return _styleSettings.nativeCssVariables;
      }
    }
  });
});